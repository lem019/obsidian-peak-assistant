import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import alias from "esbuild-plugin-alias";
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === "production");

/**
 * Custom plugin to inline WASM files as Base64 data URLs.
 * 
 * This plugin handles:
 * 1. Direct .wasm file imports (if any dependencies import .wasm files)
 * 2. Virtual module 'sqljs-wasm' that provides sql.js WASM binary as Base64
 * 3. Replaces require('sqljs-wasm') calls in source code with actual Base64 string
 */
const wasmInlinePlugin = {
	name: 'wasm-inline',
	setup(build) {
		// Pre-load WASM file once at plugin setup
		let wasmBase64 = null;
		
		// Try to load sql.js WASM file
		const loadWasmFile = async () => {
			if (wasmBase64 !== null) {
				return wasmBase64;
			}
			
			const possiblePaths = [
				path.join(__dirname, 'node_modules', 'sql.js', 'dist', 'sql-wasm.wasm'),
				path.join(__dirname, 'node_modules', 'sql.js', 'dist', 'sql-wasm.wasm.js'),
			];

			for (const wasmPath of possiblePaths) {
				try {
					if (fs.existsSync(wasmPath)) {
						const wasmBytes = await fs.promises.readFile(wasmPath);
						wasmBase64 = wasmBytes.toString('base64');
						console.log(`[wasm-inline] Loaded sql.js WASM from: ${wasmPath} (${wasmBase64.length} bytes Base64)`);
						return wasmBase64;
					}
				} catch (error) {
					// Try next path
					continue;
				}
			}
			
			console.warn(`[wasm-inline] Could not find sql.js WASM file. Tried: ${possiblePaths.join(', ')}`);
			return null;
		};

		// Handle virtual module 'sqljs-wasm' that provides sql.js WASM binary
		build.onResolve({ filter: /^sqljs-wasm$/ }, (args) => {
			return { path: args.path, namespace: 'sqljs-wasm' };
		});

		build.onLoad({ filter: /.*/, namespace: 'sqljs-wasm' }, async (args) => {
			const base64 = await loadWasmFile();
			if (!base64) {
				throw new Error('Could not load sql.js WASM file');
			}
			
			// Export as CommonJS module (since we're using format: 'cjs')
			// Use JSON.stringify to properly escape the base64 string
			return {
				contents: `module.exports = { wasmBase64: ${JSON.stringify(base64)} };`,
				loader: 'js',
			};
		});

		// Also replace require('sqljs-wasm') calls in source files
		build.onLoad({ filter: /SqlJsStore\.ts$/ }, async (args) => {
			try {
				const contents = await fs.promises.readFile(args.path, 'utf8');
				if (contents.includes('sqljs-wasm')) {
					const base64 = await loadWasmFile();
					if (base64) {
						// Replace require('sqljs-wasm') with the actual module export
						// Match various formats: require('sqljs-wasm'), require("sqljs-wasm"), etc.
						const replaced = contents.replace(
							/const wasmModule = require\(['"]sqljs-wasm['"]\);/g,
							`const wasmModule = { wasmBase64: ${JSON.stringify(base64)} };`
						);
						if (replaced !== contents) {
							console.log(`[wasm-inline] Replaced require('sqljs-wasm') in ${args.path}`);
							return {
								contents: replaced,
								loader: 'ts',
							};
						}
					}
				}
			} catch (error) {
				// If replacement fails, continue with normal processing
				console.warn(`[wasm-inline] Could not replace require('sqljs-wasm') in ${args.path}:`, error.message);
			}
			return undefined; // Let esbuild handle it normally
		});

		// Handle direct .wasm file imports
		build.onResolve({ filter: /\.wasm$/ }, (args) => {
			// Resolve WASM files to absolute paths
			let wasmPath = args.path;
			if (!path.isAbsolute(wasmPath)) {
				// Resolve relative to the importing file
				wasmPath = path.resolve(path.dirname(args.importer), wasmPath);
			}
			return { path: wasmPath, namespace: 'wasm-inline' };
		});

		// Load WASM files and convert to Base64 data URL
		build.onLoad({ filter: /.*/, namespace: 'wasm-inline' }, async (args) => {
			try {
				const wasmBytes = await fs.promises.readFile(args.path);
				const base64 = wasmBytes.toString('base64');
				const dataUrl = `data:application/wasm;base64,${base64}`;
				
				return {
					contents: `export default "${dataUrl}";`,
					loader: 'js',
				};
			} catch (error) {
				console.error(`[wasm-inline] Failed to load WASM file: ${args.path}`, error);
				throw error;
			}
		});
	},
};

/**
 * Plugin to fix createRequire(import.meta.url) issues in bundled code
 * Some packages like @langchain/community use createRequire(import.meta.url)
 * In CommonJS output, we can use __filename directly instead
 */
const fixImportMetaPlugin = {
	name: 'fix-import-meta',
	setup(build) {
		// NOTE: args.path uses OS-specific separators. Use [\\/] so this works on Windows too.
		// We keep this scoped to @langchain packages only, and then only modify files that actually
		// contain createRequire(import.meta.url) patterns.
		build.onLoad({ filter: /node_modules[\\/]@langchain[\\/].*\.(js|mjs|cjs)$/ }, async (args) => {
			try {
				const contents = await fs.promises.readFile(args.path, 'utf8');
				
				// Fix createRequire(import.meta.url) patterns
				// In CommonJS, __filename is available, so we can use it directly
				let modified = contents;
				
				// Pattern: createRequire(import.meta.url)
				// Replace with createRequire(__filename) for CommonJS.
				// Important: Some dependencies call it as a member (e.g. module.createRequire(import.meta.url)).
				// Replacing the call with an IIFE would break syntax like `obj.(...)`, so keep it as a call.
				if (contents.includes('createRequire(import.meta.url)')) {
					modified = modified.replace(
						/createRequire\(import\.meta\.url\)/g,
						'createRequire(__filename)'
					);
				}
				
				// Pattern: createRequire(import.meta.url || ...)
				if (contents.includes('createRequire(import.meta.url')) {
					modified = modified.replace(
						/createRequire\(import\.meta\.url(?:\s*\|\|[^\)]*)?\)/g,
						'createRequire(__filename)'
					);
				}

				if (modified !== contents) {
					return {
						contents: modified,
						loader: 'js',
					};
				}
			} catch (error) {
				// If we can't read/modify the file, just return undefined to use default handling
				console.warn(`[fix-import-meta] Could not process ${args.path}:`, error.message);
			}
		});
	},
};

const shared = {
	banner: { js: banner },
	bundle: true,
	platform: "node",
	plugins: [
		alias({
			"@": path.resolve(__dirname, "src"),
		}),
		fixImportMetaPlugin,
		wasmInlinePlugin, // For any .wasm file imports (may not be needed for sql.js)
	],
	external: [
		"obsidian",
		"electron",
		"better-sqlite3", // Mark as external so it loads from node_modules (native module)
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		"playwright",
		"playwright-core",
		"chromium-bidi",
		...builtins,
	],
	loader: {
		".woff": "empty",
		".woff2": "empty",
		".ttf": "empty",
		".eot": "empty",
		// WASM files are inlined as Base64 data URLs by wasmInlinePlugin (if any dependencies import .wasm files)
		// Note: sql.js loads WASM dynamically, so this may not be needed
	},
	jsx: "automatic",
	jsxImportSource: "react",
	target: "es2018",
	logLevel: "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	minify: prod,
};

const mainContext = await esbuild.context({
	...shared,
	entryPoints: ["main.ts"],
	format: "cjs",
	outfile: "main.js",
});

if (prod) {
	await mainContext.rebuild();
	process.exit(0);
} else {
	await mainContext.watch();
}
