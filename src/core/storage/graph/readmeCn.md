# 设计建议：图查询方案

本插件图查询方案的核心思路如下，重点在于 SQLite 与 Graphology 之间的协同机制：

---

## 1. 存储层 — 持久化 SQLite 存储

- **结构化设计**：所有节点和边信息都统一存储在 SQLite 数据库（sql.js 或 better-sqlite3）中，非常适合在 Obsidian 插件环境下的本地运行。
- **支持的数据**：
  - 文档节点及其元数据
  - 节点之间的所有关系（如标签、链接、分类等显式边）
- **核心优势**：
  - 高效且轻量：插入、删除和邻居节点搜索等基础操作通过 SQL 执行，提供良好的性能。
  - 仅使用持久化存储，因此不会消耗过多内存。

---

## 2. 查询层 — 图结构查询

- **基础查询**：常见的图相关查询（例如获取邻居、N 跳遍历）都使用 SQLite 中的 SQL 高效且可靠地实现。
- **SQL 覆盖范围**：大多数简单且常规的结构关系分析直接依赖 SQLite/SQL，无需将整个大图加载到内存中。

---

## 3. 动态分析层 — 内存 Graphology 图

- **按需临时构建**：只有当用户需要高级图算法（如社区检测、最短路径、多级图分析等）时，才会从 SQLite 读取相关的节点和边，并临时构建一个内存中的 Graphology 图对象。
- **极简图结构**：内存图仅存储必要的图结构：
  - **仅节点 ID**（不包含属性、类型、标签等元数据）
  - **边的连接和权重**（不包含边类型或属性）
  - 这可以在保持算法执行所需的图拓扑结构的同时，将内存占用降至最低。
- **按需加载元数据**：元数据（属性、类型、标签）存储在 SQLite 中，并在需要时通过 `GraphStore.getNode()` 按需查询，而不是预先加载到内存中。
- **选择性加载**：支持仅加载指定中心节点 N 跳（通常为 2 跳）范围内的节点，避免在大数据集中加载全量图。
- **极小开销**：通常情况下，不会持久存在大型内存图对象；它们仅用于分析，并在分析完成后立即释放。
- **示例工作流**：
  1. 用户触发分析 → SQLite 查询 2 跳内所需的节点 ID 和边连接 → 构建极简内存图（仅 ID + 连接）。
  2. 使用 Graphology 执行图算法分析。
  3. 如果需要，从 SQLite 按需查询元数据。
  4. 算法结束后，内存结构被销毁，内存自动释放。

---

## 4. 总结

- **数据始终驻留在 SQLite 中，保持插件的轻量、稳定和高效。**
- **仅在真正需要复杂分析时才使用 Graphology 构建内存图，节省资源。**
- **绝大多数查询和显示任务由 SQLite 高效处理。**

---

**设计原则**
- 仅使用 SQLite 持久化整个图结构（节点、边和所有元数据），支持所有基础关系查询。
- 仅将 Graphology 用于高级图算法分析，且始终以临时且极简的方式进行。
- 内存图仅存储核心结构（节点 ID 和连接），不存储元数据。
- 元数据（属性、类型、标签）保留在 SQLite 中，并根据需要按需查询。
- 支持选择性加载：仅加载分析所需的子图（例如 2 跳邻域），而不是整个图。
